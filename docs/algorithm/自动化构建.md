### 自动化构建

自动化构建

## 一. 自动化简介

> 一切重复工作本应该自动化

> 自动化构建是前端工程化当中非常重要的组成部分。自动化指的是机器代替手工的一些工作，构建可以把它理解成转换。

![](/images/js12.png)

总的来说，开发行业当中的自动化构建就是把开发阶段写出来的源代码自动化地装换成生产环境中可以运行的代码或者程序。一般我们把这个转换的过程称作自动化构建工作流，它的作用就是让我们尽可能脱离运行环境兼容带来的问题，在开发阶段使用提高效率的语法、规范和标准。

最典型的运用场景就是在去开发网页应用时就可以使用：

- ECMAScript Next
- Sass
- 模板引擎

> 但是这些用发都不被浏览器直接支持，此时自动化构建工具就可以派上用场了，可以通过自动化构建的方式构建转换这些不被支持的特性，从而提高开发阶段的编码效率。

## 二. 常用的自动化构建工具

NPM Scripts 是实现自动化构建工作流的最简方式，它虽然能解决一部分自动化构建任务，但是对于相对复杂的构建过程就显得非常吃力，此时我们就需要更为专业的构建工具。

目前市面上开发者使用最多的几个工具主要就是 Grunt、Gulp 以及 FIS，可能会有人问：Webpack 去哪了？ 严格来说，Webpack 实际上是一个模块打包工具，所以不在我们的讨论范围内。

![](/images/js13.png)

这些工具都可以帮助解决重复、无聊的工作从而实现自动化，用法上它们也大体相同，都是先通过一些简单的代码去组织一些插件的使用，然后就可以使用这些工具去帮你执行各种各样重复的工作了。

Grunt 可以算是最早的前端构建系统了，它的插件生态非常的完善，用官方的一句话来说就是

> Grunt 的插件几乎可以帮你自动化地去完成任何你想要做的事情。

但是由于它的工作过程是基于临时文件去实现的，所以它的构建速度会相对比较慢，且处理的环节越多，文件的读写次数越多。因此对于超大型项目，文件会非常多，它的构建速度就会非常慢。

Gulp 很好的解决了 Grunt 中构建速度慢的问题，因为它是基于内存去实现的，也就是说它对于文件的处理环节都是在内存当中完成的，相对于磁盘读写速度自然就快了很多。另外它支持同时去执行多个任务，效率大大提高，且使用方式相比于 Grunt 更加直观易懂，插件生态同样非常完善，应该算是目前市面上最流行的前端构建系统了。

FIS 是百度的前端团队推出的一款构建系统，最早只在团队内部使用，后来开源过后在国内快速流行。相对于前两个构建系统这种微内核的特点，FIS 跟像是一种捆绑套餐，它把我们在项目中一些典型的需求尽可能地都集成在内部了，例如资源加载、模块化开发、代码部署甚至是性能优化，正是因为这种大而全，所以在国内很多项目中就流行开来。

## 三. 自动化构建工具 Grunt

### Grunt 基本使用

1.初始化项目中的 package.json

```js
yarn init --yes
```

2.添加 grunt 模块

```js
yarn add grunt --dev
```

3.在项目根目录下添加 gruntfile.js 入口文件

```js
code gruntfile.js
```

4.在 gruntfile.js 中通过 registerTask()添加任务

```js
// Grunt 的入口文件
// 用于定义一些需要 Grunt 自动执行的任务
// 需要导出一个函数
// 此函数接收一个 grunt 的对象类型的形参
// grunt 对象中提供一些创建任务时会用到的 API

module.exports = (grunt) => {
  // 参数 任务名 [任务描述: grunt帮助信息中] 任务函数
  grunt.registerTask("foo", "a sample task", () => {
    console.log("hello grunt");
  });
};
```

5.运行任务 foo

```js
yarn grunt foo
```

当然，在 gruntfile.js 中，你不仅仅可以添加一个任务，还可以添加更多的任务。除此之外如果在创建任务时，任务名称为 default 时，这个任务将会成为 grunt 的默认任务，在运行时就不需要指定任务的名称，grunt 将自动调用 default，一般我们会用 default 映射一些其他的任务。

默认 grunt 采用同步模式编码，如果需要异步可以使用 this.async() 方法创建回调函数。

// gruntfile.js

```js
module.exports = (grunt) => {
  // 第二个参数可以指定此任务的映射任务，
  // 这样执行 default 就相当于执行对应的任务
  // 这里映射的任务会按顺序依次执行，不会同步执行
  grunt.registerTask("default", ["foo", "bar"]);

  // 也可以在任务函数中执行其他任务
  grunt.registerTask("run-other", () => {
    // foo 和 bar 会在当前任务执行完成过后自动依次执行
    grunt.task.run("foo", "bar");
    console.log("current task runing~");
  });

  // 默认 grunt 采用同步模式编码
  // 如果需要异步可以使用 this.async() 方法创建回调函数
  // grunt.registerTask('async-task', () => {
  // setTimeout(() => {
  // console.log('async task working~')
  // }, 1000)
  // })

  // 由于函数体中需要使用 this，所以这里不能使用箭头函数
  grunt.registerTask("async-task", function () {
    const done = this.async();
    setTimeout(() => {
      console.log("async task working~");
      done(); // 标识任务已完成
    }, 1000);
  });
};
```
